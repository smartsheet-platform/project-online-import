<env_merge_strategy>
  <!--
    CRITICAL: .env File Merging Strategy
    
    This file defines how to properly merge variables from .env.sample into an existing .env file
    WITHOUT overwriting existing values.
  -->

  <overview>
    When a target project already has an existing .env file, we must APPEND new variables
    from .env.sample without overwriting any existing values. This preserves user's
    existing configuration while adding new required variables.
  </overview>

  <merge_principles>
    <principle priority="critical">
      NEVER overwrite existing variable values in the target .env file
    </principle>
    <principle priority="critical">
      Only add variables that don't already exist in the target .env
    </principle>
    <principle priority="high">
      Preserve all comments and formatting from .env.sample for new variables
    </principle>
    <principle priority="high">
      Maintain the logical grouping of variables (keep related vars together)
    </principle>
  </merge_principles>

  <merge_workflow>
    <step number="1">
      <title>Check if .env exists</title>
      <command>test -f .env && echo "exists" || echo "missing"</command>
      <action>
        If missing: Copy .env.sample to .env and proceed with Phase 1 variable population
        If exists: Proceed to merge strategy
      </action>
    </step>

    <step number="2">
      <title>Identify variables to merge</title>
      <description>
        Extract all variable names from .env.sample and check which ones
        are missing from the existing .env file
      </description>
      <implementation>
        <bash_script><![CDATA[
# Extract variable names from .env.sample (lines starting with VARNAME=)
# Exclude comments and empty lines
grep -E '^[A-Z_]+=' .env.sample | cut -d= -f1 > /tmp/sample_vars.txt

# Check which variables are missing from existing .env
missing_vars=()
while IFS= read -r var; do
  if ! grep -q "^${var}=" .env 2>/dev/null; then
    missing_vars+=("$var")
  fi
done < /tmp/sample_vars.txt

# Display what will be added
if [ ${#missing_vars[@]} -gt 0 ]; then
  echo "Variables to add to .env:"
  printf '  - %s\n' "${missing_vars[@]}"
else
  echo "All variables from .env.sample already exist in .env"
fi
        ]]></bash_script>
      </implementation>
    </step>

    <step number="3">
      <title>Merge missing variables with context</title>
      <description>
        For each missing variable, extract it along with its comments and context
        from .env.sample and append to .env
      </description>
      <implementation>
        <bash_script><![CDATA[
# Function to extract variable with its comment block
extract_var_with_comments() {
  local var_name="$1"
  local in_comment_block=false
  local comment_block=""
  local found_var=false
  
  while IFS= read -r line; do
    # Check if this is the variable line
    if [[ "$line" =~ ^${var_name}= ]]; then
      # Output accumulated comments and the variable
      if [ -n "$comment_block" ]; then
        echo "$comment_block"
      fi
      echo "$line"
      found_var=true
      break
    fi
    
    # Accumulate comment lines before the variable
    if [[ "$line" =~ ^#.*$ ]] || [[ -z "$line" ]]; then
      if [ -n "$comment_block" ]; then
        comment_block="${comment_block}"$'\n'"${line}"
      else
        comment_block="$line"
      fi
    else
      # Reset comment block if we hit a different variable
      comment_block=""
    fi
  done < .env.sample
}

# Append missing variables to .env
if [ ${#missing_vars[@]} -gt 0 ]; then
  echo "" >> .env
  echo "# Variables added from .env.sample on $(date)" >> .env
  
  for var in "${missing_vars[@]}"; do
    echo "" >> .env
    extract_var_with_comments "$var" >> .env
  done
  
  echo "✅ Added ${#missing_vars[@]} new variables to .env"
else
  echo "✅ No new variables to add"
fi
        ]]></bash_script>
      </implementation>
    </step>

    <step number="4">
      <title>Validate merge results</title>
      <description>
        Verify that all variables from .env.sample now exist in .env
        and that no existing values were overwritten
      </description>
      <validation>
        <bash_script><![CDATA[
# Check that all variables from .env.sample exist in .env
all_present=true
while IFS= read -r var; do
  if ! grep -q "^${var}=" .env; then
    echo "❌ Missing variable: $var"
    all_present=false
  fi
done < /tmp/sample_vars.txt

if [ "$all_present" = true ]; then
  echo "✅ All variables from .env.sample are present in .env"
else
  echo "❌ Some variables are still missing"
fi

# Clean up temp file
rm -f /tmp/sample_vars.txt
        ]]></bash_script>
      </validation>
    </step>
  </merge_workflow>

  <simplified_merge_command>
    <description>
      A simpler approach using awk to merge .env.sample into existing .env
    </description>
    <command><![CDATA[
# Backup existing .env
cp .env .env.backup

# Merge: Keep all existing .env values, add missing vars from .env.sample
awk '
  # First pass: read existing .env and store all variable names
  NR==FNR {
    if ($0 ~ /^[A-Z_]+=/) {
      split($0, a, "=")
      existing[a[1]] = 1
    }
    next
  }
  
  # Second pass: process .env.sample
  {
    # If this is a variable line
    if ($0 ~ /^[A-Z_]+=/) {
      split($0, a, "=")
      var_name = a[1]
      
      # Only output if variable does not exist in .env
      if (!(var_name in existing)) {
        if (!header_printed) {
          print ""
          print "# Variables added from .env.sample on " strftime("%Y-%m-%d")
          header_printed = 1
        }
        print ""
        # Print any accumulated comments
        for (i in comments) {
          print comments[i]
        }
        delete comments
        print $0
      } else {
        # Variable exists, skip it and clear comments
        delete comments
      }
    }
    # Accumulate comments and empty lines
    else if ($0 ~ /^#/ || $0 == "") {
      comments[length(comments)] = $0
    }
    # Other lines reset comment accumulation
    else {
      delete comments
    }
  }
' .env .env.sample >> .env

echo "✅ Merged .env.sample into .env (backup saved as .env.backup)"
    ]]></command>
  </simplified_merge_command>

  <interactive_merge_approach>
    <description>
      For Dev Env mode: Interactive approach that asks user about each new variable
    </description>
    <workflow>
      <step>Check if .env exists, if not copy from .env.sample</step>
      <step>Identify missing variables from .env.sample</step>
      <step>For each missing variable, ask user if they want to add it</step>
      <step>If yes, ask if they want to provide a value now or leave empty</step>
      <step>Append variable with its comments to .env</step>
      <step>Validate all required variables are present</step>
    </workflow>
  </interactive_merge_approach>

  <phase_1_integration>
    <description>
      How this merging strategy integrates with Phase 1 workflow
    </description>
    
    <scenario name="new_project">
      <condition>.env does not exist</condition>
      <action>Copy .env.sample to .env, then proceed with Phase 1 variable population</action>
    </scenario>
    
    <scenario name="existing_project">
      <condition>.env exists but missing some variables from .env.sample</condition>
      <action>
        1. Merge missing variables from .env.sample into .env
        2. Identify which required variables are still empty
        3. Proceed with Phase 1 to populate only the empty required variables
        4. Do NOT re-prompt for variables that already have values
      </action>
    </scenario>
    
    <scenario name="fully_configured">
      <condition>.env exists with all variables from .env.sample</condition>
      <action>
        1. Validate all required variables have values
        2. If GIT_TOKEN is empty, prompt for it
        3. If Jira vars are empty, ask if user wants to configure Jira
        4. Skip to Phase 2 if everything is configured
      </action>
    </scenario>
  </phase_1_integration>

  <critical_rules>
    <rule>NEVER use sed -i to replace entire lines - this overwrites existing values</rule>
    <rule>ALWAYS check if a variable exists before adding it</rule>
    <rule>ALWAYS preserve existing variable values</rule>
    <rule>ONLY prompt user for variables that are empty or missing</rule>
    <rule>When updating a variable value, use sed to replace only that specific variable</rule>
  </critical_rules>

  <safe_variable_update>
    <description>
      How to safely update a specific variable value without affecting others
    </description>
    <example>
      <bash_script><![CDATA[
# Safe way to update a specific variable
VAR_NAME="GIT_TOKEN"
NEW_VALUE="ghp_xxxxxxxxxxxx"

# Update only this variable, preserving all others
sed -i.bak "s|^${VAR_NAME}=.*|${VAR_NAME}=${NEW_VALUE}|" .env

# Verify the update
grep "^${VAR_NAME}=" .env
      ]]></bash_script>
    </example>
  </safe_variable_update>

  <recommended_implementation>
    <description>
      Recommended implementation for Dev Env mode
    </description>
    
    <step number="1">
      <title>Initial Check</title>
      <code><![CDATA[
if [ ! -f .env ]; then
  echo "Creating .env from .env.sample..."
  cp .env.sample .env
  echo "✅ Created .env file"
else
  echo "✅ .env file exists"
fi
      ]]></code>
    </step>
    
    <step number="2">
      <title>Merge Missing Variables</title>
      <code><![CDATA[
# Backup existing .env
cp .env .env.backup.$(date +%Y%m%d_%H%M%S)

# Use awk to merge (see simplified_merge_command above)
# This preserves all existing values and only adds missing variables
      ]]></code>
    </step>
    
    <step number="3">
      <title>Identify Empty Required Variables</title>
      <code><![CDATA[
# Check which required variables are empty
if ! grep -q "^GIT_TOKEN=.\+$" .env; then
  echo "⚠️ GIT_TOKEN needs to be configured"
  NEEDS_GIT_TOKEN=true
fi

if ! grep -q "^JIRA_USERNAME=.\+$" .env || ! grep -q "^JIRA_API_TOKEN=.\+$" .env; then
  echo "ℹ️ Jira integration is not configured (optional)"
  JIRA_NOT_CONFIGURED=true
fi
      ]]></code>
    </step>
    
    <step number="4">
      <title>Interactive Population of Empty Variables</title>
      <code><![CDATA[
# Only prompt for variables that are empty
if [ "$NEEDS_GIT_TOKEN" = true ]; then
  echo "GIT_TOKEN is required for MR feedback processing"
  read -p "Enter your Git platform token: " git_token
  sed -i.bak "s|^GIT_TOKEN=.*|GIT_TOKEN=${git_token}|" .env
fi

if [ "$JIRA_NOT_CONFIGURED" = true ]; then
  read -p "Would you like to configure Jira integration? (y/n): " configure_jira
  if [ "$configure_jira" = "y" ]; then
    # Collect Jira credentials and update .env
    # (see Phase 1 workflow for details)
  fi
fi
      ]]></code>
    </step>
  </recommended_implementation>
</env_merge_strategy>