<knowledge_patterns>
  <overview>
    Standard templates for structuring extracted project knowledge and AI agent guidance.
  </overview>

  <output_structure>
    <bootstrap_main_template>
# sdlc/docs/code/BOOTSTRAP-[project-name].md

## Project Overview

**Architecture Pattern**: [MVC/Microservices/Event-Driven/Layered/etc.]
**Primary Language(s)**: [Languages with versions]
**Key Frameworks**: [Frameworks with versions]

### Purpose
[What this project does and its primary goals]

### Key Architectural Principles
- [Principle 1: e.g., Domain-Driven Design]
- [Principle 2: e.g., Dependency Injection]
- [Principle 3: e.g., Event-Driven Communication]

---

## Technology Stack

| Component | Technology | Version | Rationale |
|-----------|-----------|---------|-----------|
| Backend | [e.g., Python/FastAPI] | [3.11/0.104] | [Why chosen: async support, type safety] |
| Frontend | [e.g., React/TypeScript] | [18/5.2] | [Why chosen: component model, type safety] |
| Database | [e.g., PostgreSQL] | [15] | [Why chosen: ACID, JSON support] |
| Cache | [e.g., Redis] | [7] | [Why chosen: performance, pub/sub] |
| Message Queue | [e.g., RabbitMQ] | [3.12] | [Why chosen: reliability, routing] |

### Key Dependencies
- **[Library Name]** ([version]): [Purpose and why it's critical]
- **[Library Name]** ([version]): [Purpose and why it's critical]

---

## Architecture

### Component Organization
```
project/
├── src/
│   ├── domain/          # Business logic (pure, no framework deps)
│   │   ├── entities/    # Core business entities
│   │   ├── services/    # Domain services
│   │   └── events/      # Domain events
│   ├── application/     # Use cases and orchestration
│   │   ├── commands/    # Command handlers
│   │   ├── queries/     # Query handlers
│   │   └── dto/         # Data transfer objects
│   ├── infrastructure/  # Framework, DB, external APIs
│   │   ├── persistence/ # Database implementations
│   │   ├── messaging/   # Message queue implementations
│   │   └── external/    # External API clients
│   └── interfaces/      # Controllers, CLI, API endpoints
│       ├── api/         # REST/GraphQL endpoints
│       ├── cli/         # Command-line interface
│       └── events/      # Event listeners
```

**Convention**: Domain layer must never import from infrastructure or interfaces

### Data Flow
[Describe typical request flow through the architecture]
1. Request enters via [interface layer]
2. [Application layer] orchestrates use case
3. [Domain layer] executes business logic
4. [Infrastructure layer] handles persistence/external calls
5. Response returns through layers

### Service Boundaries
[For microservices/distributed systems]
- **[Service Name]**: [Responsibility and boundaries]
- **[Service Name]**: [Responsibility and boundaries]

**Communication**: [REST/gRPC/Events/etc.]

---

## Code Organization Conventions

### Naming Conventions

**Files**:
- Components: `PascalCase.tsx` (e.g., `UserProfile.tsx`)
- Services: `snake_case.py` (e.g., `user_service.py`)
- Tests: `test_*.py` or `*.spec.ts`

**Functions/Methods**:
- Public API: `camelCase` or `snake_case` (language-specific)
- Private: `_prefixed_snake_case` or `#privateMethod`
- Event handlers: `on[Event]` (e.g., `onUserCreated`)

**Variables**:
- Constants: `UPPER_SNAKE_CASE`
- Configuration: `UPPER_SNAKE_CASE` with prefix (e.g., `DB_HOST`)
- Local variables: `camelCase` or `snake_case`

### Module Organization
- One class/component per file
- Related utilities grouped in `utils/` subdirectories
- Shared types in `types/` or `models/`
- Tests colocated with implementation or in parallel `__tests__/` directory

---

## Common Patterns

### Error Handling Pattern

**DO** - Use custom exceptions with context:
```python
# src/domain/exceptions.py
class ValidationError(DomainException):
    def __init__(self, message: str, field: str, context: dict):
        super().__init__(message)
        self.field = field
        self.context = context

# Usage
raise ValidationError(
    message="Invalid email format",
    field="email",
    context={"provided": email, "expected_format": "user@domain.com"}
)
```

**DON'T** - Generic exceptions without context:
```python
raise Exception("Invalid email")  # ❌ No context, hard to debug
```

### API Integration Pattern

**DO** - Abstract external APIs with interfaces:
```typescript
// src/infrastructure/external/user-api-client.ts
interface UserApiClient {
  getUser(id: string): Promise<User>;
  createUser(data: CreateUserDto): Promise<User>;
}

class HttpUserApiClient implements UserApiClient {
  constructor(
    private httpClient: HttpClient,
    private config: ApiConfig
  ) {}
  
  async getUser(id: string): Promise<User> {
    try {
      const response = await this.httpClient.get(
        `${this.config.baseUrl}/users/${id}`,
        { timeout: 5000, retries: 3 }
      );
      return this.mapToUser(response.data);
    } catch (error) {
      throw new UserApiError(`Failed to fetch user ${id}`, error);
    }
  }
}
```

**DON'T** - Direct API calls scattered throughout code:
```typescript
// ❌ Tight coupling, no error handling, no retry logic
const user = await fetch(`https://api.example.com/users/${id}`);
```

### Configuration Management Pattern

**DO** - Centralized, typed configuration:
```python
# src/infrastructure/config.py
from pydantic import BaseSettings

class Settings(BaseSettings):
    # Database
    DB_HOST: str
    DB_PORT: int = 5432
    DB_NAME: str
    
    # External APIs
    USER_API_BASE_URL: str
    USER_API_TIMEOUT: int = 5000
    
    # Feature Flags
    ENABLE_CACHING: bool = True
    
    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

**DON'T** - Environment variables accessed directly:
```python
import os
db_host = os.getenv("DB_HOST")  # ❌ No validation, no defaults, no types
```

### Logging Pattern

**DO** - Structured logging with context:
```python
logger.info(
    "User created successfully",
    extra={
        "user_id": user.id,
        "email": user.email,
        "created_by": current_user.id,
        "timestamp": datetime.utcnow().isoformat()
    }
)
```

**DON'T** - Unstructured string logging:
```python
print(f"User {user.id} created")  # ❌ Not searchable, no context
```

---

## Anti-Patterns to Avoid

### 1. God Objects
**What**: Classes with too many responsibilities

**Why it's wrong**: Violates Single Responsibility Principle, hard to test and maintain

**Example of anti-pattern**:
```python
class UserManager:  # ❌ Does everything
    def create_user(self): ...
    def send_email(self): ...
    def process_payment(self): ...
    def generate_report(self): ...
```

**Correct approach**:
```python
class UserService:  # ✅ Single responsibility
    def create_user(self): ...

class EmailService:
    def send_email(self): ...

class PaymentService:
    def process_payment(self): ...
```

### 2. Circular Dependencies
**What**: Module A imports B, B imports A

**Why it's wrong**: Makes code fragile, hard to test, causes import errors

**Detection**: Look for import cycles in module dependency graph

**Correct approach**: Use dependency injection, introduce interfaces, or restructure modules

### 3. Leaky Abstractions
**What**: Implementation details exposed through interfaces

**Example of anti-pattern**:
```python
def get_user(self) -> dict:  # ❌ Exposes database structure
    return self.db.query("SELECT * FROM users WHERE id = ?")
```

**Correct approach**:
```python
def get_user(self, user_id: str) -> User:  # ✅ Returns domain entity
    row = self.db.query("SELECT * FROM users WHERE id = ?", user_id)
    return User.from_dict(row)
```

---

## Integration Patterns

### External API Integration

**Pattern**: Client → Adapter → Domain
```
[External API] ← [API Client] ← [Adapter] ← [Domain Service]
```

**Responsibilities**:
- **API Client**: HTTP calls, retries, timeouts, authentication
- **Adapter**: Maps external data to domain entities
- **Domain Service**: Business logic using domain entities

**Example**: See `src/infrastructure/external/` for implementations

### Database Access

**Pattern**: Repository pattern with ORM abstraction
```python
# Domain defines interface
class UserRepository(ABC):
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]: ...
    
    @abstractmethod
    def save(self, user: User) -> None: ...

# Infrastructure implements
class SqlAlchemyUserRepository(UserRepository):
    def find_by_id(self, user_id: str) -> Optional[User]:
        row = self.session.query(UserModel).filter_by(id=user_id).first()
        return User.from_orm(row) if row else None
```

### Event-Driven Communication

**Pattern**: Domain events with async handlers
```python
# Domain publishes events
class User:
    def create(self):
        # ... creation logic
        self.add_event(UserCreatedEvent(user_id=self.id))

# Infrastructure handles events
@event_handler(UserCreatedEvent)
async def send_welcome_email(event: UserCreatedEvent):
    await email_service.send_welcome(event.user_id)
```

---

## Configuration Management

### Environment Variables

**Required**:
- `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, `DB_PASSWORD`
- `API_KEY_[SERVICE_NAME]` for each external service
- `LOG_LEVEL` (default: INFO)

**Optional**:
- `ENABLE_[FEATURE]` for feature flags (default: false)
- `CACHE_TTL` (default: 3600)
- `MAX_RETRIES` (default: 3)

**Naming Convention**: `[COMPONENT]_[PROPERTY]` in UPPER_SNAKE_CASE

### Secrets Management
- Never commit secrets to git
- Use `.env` for local development (git-ignored)
- Use secret management service in production (e.g., AWS Secrets Manager)
- Rotate secrets regularly

### Feature Flags
```python
if settings.ENABLE_NEW_FEATURE:
    # New implementation
else:
    # Legacy implementation
```

---

## Testing Strategy

### Coverage Expectations
- **Unit Tests**: 80%+ coverage for domain and application layers
- **Integration Tests**: Critical workflows and external integrations
- **E2E Tests**: Happy paths for key user journeys

### Test Organization
```
tests/
├── unit/           # Fast, isolated tests
├── integration/    # Tests with real dependencies
└── e2e/           # Full system tests
```

### Testing Patterns

**Unit Test Example**:
```python
def test_user_creation_validates_email():
    # Arrange
    invalid_email = "not-an-email"
    
    # Act & Assert
    with pytest.raises(ValidationError) as exc:
        User.create(email=invalid_email)
    
    assert exc.value.field == "email"
```

**Integration Test Example**:
```python
@pytest.mark.integration
async def test_user_api_client_retries_on_failure(mock_server):
    # Arrange
    mock_server.fail_times(2)  # Fail first 2 attempts
    client = UserApiClient(config)
    
    # Act
    user = await client.get_user("123")
    
    # Assert
    assert user.id == "123"
    assert mock_server.call_count == 3  # Retried twice
```

---

## Git Workflow

### Branch Naming
- Feature: `feature/JIRA-123-short-description`
- Bugfix: `bugfix/JIRA-456-short-description`
- Hotfix: `hotfix/JIRA-789-short-description`

### Commit Messages
```
<type>(<scope>): <subject>

<body>

<footer>
```

**Types**: feat, fix, docs, style, refactor, test, chore

**Example**:
```
feat(user-service): add email validation

- Implement regex-based email validation
- Add custom ValidationError with field context
- Update tests for new validation logic

Closes JIRA-123
```

### Pull Request Requirements
- [ ] All tests passing
- [ ] Code coverage maintained or improved
- [ ] Documentation updated
- [ ] No linting errors
- [ ] Reviewed by at least one team member

---

## Troubleshooting Playbook

### Symptom: Database Connection Timeout

**Likely Causes**:
1. Database server not running
2. Incorrect connection credentials
3. Network/firewall blocking connection
4. Connection pool exhausted

**Diagnostics**:
```bash
# Check database is running
docker ps | grep postgres

# Test connection
psql -h $DB_HOST -U $DB_USER -d $DB_NAME

# Check connection pool
# Look for "connection pool exhausted" in logs
```

**Fixes**:
1. Start database: `docker-compose up -d postgres`
2. Verify credentials in `.env` file
3. Check firewall rules
4. Increase pool size in config or close idle connections

**Prevention**:
- Use connection pooling with appropriate limits
- Implement connection health checks
- Set reasonable timeouts
- Monitor connection pool metrics

### Symptom: External API Rate Limiting

**Likely Causes**:
1. Too many requests in short time
2. No rate limiting implementation
3. Retry logic causing amplification

**Diagnostics**:
```bash
# Check API response headers
curl -I https://api.example.com/endpoint

# Look for X-RateLimit-* headers
# Check logs for 429 status codes
```

**Fixes**:
1. Implement exponential backoff
2. Add rate limiting to client
3. Cache responses when appropriate
4. Request rate limit increase from provider

**Prevention**:
- Implement circuit breaker pattern
- Add request throttling
- Cache aggressively
- Monitor API usage metrics

---

## Decision Rationale

### Why [Architecture Pattern]?
[Explain why this architecture was chosen over alternatives]

**Trade-offs**:
- ✅ Benefit 1
- ✅ Benefit 2
- ⚠️ Trade-off 1
- ⚠️ Trade-off 2

### Why [Technology Choice]?
[Explain technology selection rationale]

**Alternatives Considered**:
- [Alternative 1]: [Why not chosen]
- [Alternative 2]: [Why not chosen]

---

## References

### Key Files
- Architecture: `src/domain/README.md`
- API Docs: `docs/api/README.md`
- Setup Guide: `docs/setup.md`

### External Documentation
- [Framework Docs](https://example.com)
- [Library Docs](https://example.com)

---

**Last Updated**: [Date]
**Bootstrap Version**: [Version]
    </bootstrap_main_template>

    <patterns_xml_template>
<!-- patterns.xml - Machine-readable patterns for AI agent guidance -->
<patterns>
  <pattern name="error_handling">
    <description>Custom exceptions with context</description>
    <example language="python">
      <![CDATA[
raise ValidationError(
    message="Invalid input",
    field="email",
    context={"provided": value}
)
      ]]>
    </example>
    <anti_pattern>
      <![CDATA[
raise Exception("Error")  # No context
      ]]>
    </anti_pattern>
  </pattern>
  
  <pattern name="api_integration">
    <description>Abstract external APIs with interfaces</description>
    <example language="typescript">
      <![CDATA[
interface ApiClient {
  get(url: string): Promise<Response>;
}

class HttpApiClient implements ApiClient {
  async get(url: string): Promise<Response> {
    // Implementation with retry, timeout, error handling
  }
}
      ]]>
    </example>
  </pattern>
</patterns>
    </patterns_xml_template>

    <conventions_xml_template>
<!-- conventions.xml - Team conventions and standards -->
<conventions>
  <naming>
    <files>
      <convention>Components: PascalCase.tsx</convention>
      <convention>Services: snake_case.py</convention>
      <convention>Tests: test_*.py or *.spec.ts</convention>
    </files>
    <functions>
      <convention>Public: camelCase or snake_case</convention>
      <convention>Private: _prefixed or #private</convention>
    </functions>
    <variables>
      <convention>Constants: UPPER_SNAKE_CASE</convention>
      <convention>Config: UPPER_SNAKE_CASE with prefix</convention>
    </variables>
  </naming>
  
  <git_workflow>
    <branches>
      <convention>feature/JIRA-123-description</convention>
      <convention>bugfix/JIRA-456-description</convention>
      <convention>hotfix/JIRA-789-description</convention>
    </branches>
    <commits>
      <format>type(scope): subject</format>
      <types>feat, fix, docs, style, refactor, test, chore</types>
    </commits>
  </git_workflow>
  
  <testing>
    <coverage>
      <target>80%+ for domain and application layers</target>
    </coverage>
    <organization>
      <structure>tests/unit/, tests/integration/, tests/e2e/</structure>
    </organization>
  </testing>
</conventions>
    </conventions_xml_template>

    <anti_patterns_xml_template>
<!-- anti-patterns.xml - Things to avoid -->
<anti_patterns>
  <anti_pattern name="god_objects">
    <description>Classes with too many responsibilities</description>
    <why_wrong>Violates Single Responsibility Principle</why_wrong>
    <detection>Class with 10+ methods or 500+ lines</detection>
    <correct_approach>Split into focused, single-purpose classes</correct_approach>
  </anti_pattern>
  
  <anti_pattern name="circular_dependencies">
    <description>Module A imports B, B imports A</description>
    <why_wrong>Makes code fragile, hard to test</why_wrong>
    <detection>Import cycle errors</detection>
    <correct_approach>Use dependency injection or introduce interfaces</correct_approach>
  </anti_pattern>
  
  <anti_pattern name="leaky_abstractions">
    <description>Implementation details exposed through interfaces</description>
    <why_wrong>Tight coupling, hard to change implementation</why_wrong>
    <detection>Database/API structures in domain layer</detection>
    <correct_approach>Return domain entities, hide implementation</correct_approach>
  </anti_pattern>
</anti_patterns>
    </anti_patterns_xml_template>
  </output_structure>

  <verification_report_template>
# VERIFICATION-bootstrap.md

## Verification Summary

**Status**: [Current/Needs Updates/Significant Drift]
**Verification Date**: [Date]
**Codebase State**: [Git commit hash]

---

## Critical Inaccuracies

### 1. [Inaccuracy Description]
**Documented**: [What bootstrap artifacts say]
**Actual**: [What codebase actually does]
**Impact**: [How this misleads AI agents]
**Recommendation**: [How to fix]

---

## Outdated Patterns

### [Pattern Name]
**Last Valid**: [Approximate date/version]
**Current Implementation**: [How it's done now]
**Files Affected**: [List of files using new pattern]
**Update Needed**: [What to change in bootstrap artifacts]

---

## Missing Patterns

### [New Pattern Discovered]
**Description**: [What the pattern does]
**Prevalence**: [How widely used in codebase]
**Example Files**: [Where to find examples]
**Should Document**: [Why AI agents need to know this]

---

## Technology Stack Updates

| Component | Documented | Actual | Action |
|-----------|-----------|--------|--------|
| [Tech] | [Old version] | [New version] | Update bootstrap |
| [Tech] | [Old version] | [New version] | Update bootstrap |

---

## New Anti-Patterns

### [Anti-Pattern Name]
**Description**: [What to avoid]
**Why It's Wrong**: [Rationale]
**Occurrences**: [Where it appears in code]
**Correct Approach**: [What to do instead]

---

## Recommendations

1. **High Priority**: [Critical updates needed]
2. **Medium Priority**: [Important but not urgent]
3. **Low Priority**: [Nice to have]

### Suggested Re-Extraction Areas
- [ ] [Area 1]: [Reason]
- [ ] [Area 2]: [Reason]

---

## Verification Details

**Files Analyzed**: [Count]
**Patterns Checked**: [Count]
**Conventions Validated**: [Count]
**Integration Points Verified**: [Count]
  </verification_report_template>
</knowledge_patterns>