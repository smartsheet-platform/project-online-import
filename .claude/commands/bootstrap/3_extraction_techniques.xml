<extraction_techniques>
  <overview>
    Systematic techniques for analyzing a codebase to extract project-specific knowledge for AI agent guidance.
    This file contains technique checklists and heuristicsâ€”no tool instructions or invocations.
  </overview>

  <architecture_analysis_techniques>
    <technique name="pattern_identification">
      <description>Identify the architectural pattern used in the project</description>
      <heuristics>
        <rule>Analyze directory structure for layer separation (MVC, Clean Architecture, Hexagonal, etc.)</rule>
        <rule>Look for domain/application/infrastructure separation</rule>
        <rule>Identify service boundaries in microservices architectures</rule>
        <rule>Check for event-driven patterns (event sourcing, CQRS)</rule>
        <rule>Examine dependency flow between layers</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Primary architectural pattern name and description</item>
        <item>Layer/component organization with responsibilities</item>
        <item>Dependency rules and constraints</item>
        <item>Communication patterns between components</item>
      </evidence_to_collect>
    </technique>

    <technique name="component_mapping">
      <description>Map major components and their relationships</description>
      <heuristics>
        <rule>Identify top-level directories and their purposes</rule>
        <rule>Map service/module boundaries and interfaces</rule>
        <rule>Trace data flow through the system</rule>
        <rule>Document component dependencies and coupling</rule>
        <rule>Identify shared libraries and utilities</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Component diagram or textual description</item>
        <item>Key interfaces between components</item>
        <item>Data flow patterns</item>
        <item>Shared dependencies</item>
      </evidence_to_collect>
    </technique>

    <technique name="decision_archaeology">
      <description>Extract architectural decisions and their rationale</description>
      <heuristics>
        <rule>Search for ADR (Architecture Decision Records) files</rule>
        <rule>Analyze git history for major structural changes</rule>
        <rule>Look for comments explaining "why" decisions were made</rule>
        <rule>Identify trade-offs in current implementation</rule>
        <rule>Document constraints that shaped the architecture</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Key architectural decisions with context</item>
        <item>Alternatives considered and why rejected</item>
        <item>Constraints that influenced choices</item>
        <item>Trade-offs accepted</item>
      </evidence_to_collect>
    </technique>
  </architecture_analysis_techniques>

  <technology_stack_techniques>
    <technique name="dependency_analysis">
      <description>Extract technology stack and dependency information</description>
      <heuristics>
        <rule>Parse package manifests (package.json, requirements.txt, pom.xml, etc.)</rule>
        <rule>Identify framework versions and compatibility requirements</rule>
        <rule>Document key libraries and their purposes</rule>
        <rule>Note build tools and development dependencies</rule>
        <rule>Check for version constraints and pinning strategies</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Complete technology stack with versions</item>
        <item>Critical dependencies and their purposes</item>
        <item>Version compatibility requirements</item>
        <item>Build and development tooling</item>
      </evidence_to_collect>
    </technique>

    <technique name="framework_usage_analysis">
      <description>Understand how frameworks are used and configured</description>
      <heuristics>
        <rule>Examine framework configuration files</rule>
        <rule>Identify custom framework extensions or plugins</rule>
        <rule>Document framework-specific patterns used</rule>
        <rule>Note deviations from framework conventions</rule>
        <rule>Check for framework version-specific features</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Framework configuration patterns</item>
        <item>Custom extensions and why they exist</item>
        <item>Framework-specific conventions followed</item>
      </evidence_to_collect>
    </technique>
  </technology_stack_techniques>

  <convention_extraction_techniques>
    <technique name="naming_convention_analysis">
      <description>Extract naming conventions across the codebase</description>
      <heuristics>
        <rule>Analyze file naming patterns (PascalCase, snake_case, kebab-case)</rule>
        <rule>Identify function/method naming conventions</rule>
        <rule>Document variable naming patterns (camelCase, snake_case)</rule>
        <rule>Extract constant naming conventions (UPPER_SNAKE_CASE)</rule>
        <rule>Note test file naming patterns</rule>
        <rule>Identify configuration variable naming (prefixes, separators)</rule>
      </heuristics>
      <evidence_to_collect>
        <item>File naming conventions with examples</item>
        <item>Function/method naming patterns</item>
        <item>Variable and constant conventions</item>
        <item>Test naming patterns</item>
      </evidence_to_collect>
    </technique>

    <technique name="code_organization_analysis">
      <description>Extract file and directory organization patterns</description>
      <heuristics>
        <rule>Document directory structure conventions</rule>
        <rule>Identify module/package organization patterns</rule>
        <rule>Note file collocation strategies (tests, types, styles)</rule>
        <rule>Extract import/export patterns</rule>
        <rule>Document code grouping strategies (by feature, by layer, by type)</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Directory structure template</item>
        <item>File organization rules</item>
        <item>Module boundaries and grouping</item>
        <item>Import/export conventions</item>
      </evidence_to_collect>
    </technique>

    <technique name="git_workflow_extraction">
      <description>Extract git workflow conventions from repository history</description>
      <heuristics>
        <rule>Analyze branch naming patterns from git history</rule>
        <rule>Extract commit message formats and conventions</rule>
        <rule>Identify PR/MR title and description patterns</rule>
        <rule>Document merge strategies (merge commits, squash, rebase)</rule>
        <rule>Note tagging and release conventions</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Branch naming convention with examples</item>
        <item>Commit message format and types</item>
        <item>PR/MR requirements and templates</item>
        <item>Merge and release strategies</item>
      </evidence_to_collect>
    </technique>
  </convention_extraction_techniques>

  <pattern_discovery_techniques>
    <technique name="error_handling_pattern_extraction">
      <description>Identify error handling patterns and conventions</description>
      <heuristics>
        <rule>Search for custom exception/error classes</rule>
        <rule>Analyze try-catch/error boundary patterns</rule>
        <rule>Document error logging and reporting approaches</rule>
        <rule>Identify error recovery and fallback strategies</rule>
        <rule>Extract error message formatting conventions</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Custom exception hierarchy</item>
        <item>Error handling patterns with examples</item>
        <item>Logging patterns for errors</item>
        <item>Recovery strategies</item>
      </evidence_to_collect>
    </technique>

    <technique name="api_integration_pattern_extraction">
      <description>Extract patterns for integrating with external APIs</description>
      <heuristics>
        <rule>Identify API client implementations and abstractions</rule>
        <rule>Document authentication and authorization patterns</rule>
        <rule>Extract retry, timeout, and circuit breaker patterns</rule>
        <rule>Analyze request/response mapping strategies</rule>
        <rule>Note error handling for external API failures</rule>
      </heuristics>
      <evidence_to_collect>
        <item>API client architecture and patterns</item>
        <item>Authentication mechanisms</item>
        <item>Resilience patterns (retry, timeout, circuit breaker)</item>
        <item>Data mapping strategies</item>
      </evidence_to_collect>
    </technique>

    <technique name="data_validation_pattern_extraction">
      <description>Extract data validation and sanitization patterns</description>
      <heuristics>
        <rule>Identify validation libraries and frameworks used</rule>
        <rule>Document validation patterns (decorators, schemas, functions)</rule>
        <rule>Extract input sanitization approaches</rule>
        <rule>Note validation error handling and reporting</rule>
        <rule>Identify where validation occurs (boundary, domain, both)</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Validation framework and patterns</item>
        <item>Validation location strategy</item>
        <item>Error reporting patterns</item>
        <item>Sanitization approaches</item>
      </evidence_to_collect>
    </technique>

    <technique name="logging_pattern_extraction">
      <description>Extract logging patterns and conventions</description>
      <heuristics>
        <rule>Identify logging framework and configuration</rule>
        <rule>Document log level usage conventions</rule>
        <rule>Extract structured logging patterns</rule>
        <rule>Note what gets logged and what doesn't</rule>
        <rule>Identify sensitive data handling in logs</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Logging framework and setup</item>
        <item>Log level conventions</item>
        <item>Structured logging patterns</item>
        <item>Sensitive data handling rules</item>
      </evidence_to_collect>
    </technique>

    <technique name="configuration_pattern_extraction">
      <description>Extract configuration management patterns</description>
      <heuristics>
        <rule>Identify configuration sources (.env, config files, CLI args)</rule>
        <rule>Document configuration loading and validation</rule>
        <rule>Extract environment-specific configuration patterns</rule>
        <rule>Note secrets management approach</rule>
        <rule>Identify feature flag patterns if present</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Configuration architecture</item>
        <item>Environment variable conventions</item>
        <item>Secrets management approach</item>
        <item>Feature flag patterns</item>
      </evidence_to_collect>
    </technique>

    <technique name="testing_pattern_extraction">
      <description>Extract testing patterns and strategies</description>
      <heuristics>
        <rule>Identify test frameworks and tools used</rule>
        <rule>Document test organization (unit, integration, e2e)</rule>
        <rule>Extract test naming conventions</rule>
        <rule>Note mocking and stubbing patterns</rule>
        <rule>Identify test data management strategies</rule>
        <rule>Document coverage expectations and enforcement</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Test framework and organization</item>
        <item>Test naming and structure conventions</item>
        <item>Mocking patterns</item>
        <item>Coverage expectations</item>
      </evidence_to_collect>
    </technique>
  </pattern_discovery_techniques>

  <anti_pattern_identification_techniques>
    <technique name="code_smell_detection">
      <description>Identify anti-patterns and code smells to avoid</description>
      <heuristics>
        <rule>Look for god objects (classes with too many responsibilities)</rule>
        <rule>Identify circular dependencies between modules</rule>
        <rule>Find leaky abstractions (implementation details exposed)</rule>
        <rule>Note tight coupling between components</rule>
        <rule>Identify duplicated code patterns</rule>
        <rule>Look for magic numbers and strings</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Common anti-patterns found</item>
        <item>Why they're problematic</item>
        <item>Correct alternatives</item>
        <item>How to detect them</item>
      </evidence_to_collect>
    </technique>

    <technique name="architectural_violation_detection">
      <description>Identify violations of architectural principles</description>
      <heuristics>
        <rule>Check for layer violations (domain importing infrastructure)</rule>
        <rule>Identify service boundary violations</rule>
        <rule>Note dependency rule violations</rule>
        <rule>Find inappropriate coupling</rule>
        <rule>Identify missing abstractions</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Architectural violations to avoid</item>
        <item>Why they violate principles</item>
        <item>Correct architectural patterns</item>
      </evidence_to_collect>
    </technique>
  </anti_pattern_identification_techniques>

  <integration_analysis_techniques>
    <technique name="external_dependency_mapping">
      <description>Map external dependencies and integration points</description>
      <heuristics>
        <rule>Identify all external APIs and services</rule>
        <rule>Document authentication mechanisms for each</rule>
        <rule>Extract API versioning strategies</rule>
        <rule>Note data transformation patterns</rule>
        <rule>Identify error handling for external failures</rule>
      </heuristics>
      <evidence_to_collect>
        <item>External dependency inventory</item>
        <item>Authentication patterns per service</item>
        <item>Integration architecture</item>
        <item>Error handling strategies</item>
      </evidence_to_collect>
    </technique>

    <technique name="database_pattern_extraction">
      <description>Extract database access and management patterns</description>
      <heuristics>
        <rule>Identify database technology and ORM/query builder</rule>
        <rule>Document repository or data access patterns</rule>
        <rule>Extract migration and schema management approach</rule>
        <rule>Note transaction management patterns</rule>
        <rule>Identify connection pooling and management</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Database technology and access patterns</item>
        <item>Repository/DAO patterns</item>
        <item>Migration strategy</item>
        <item>Transaction patterns</item>
      </evidence_to_collect>
    </technique>

    <technique name="messaging_pattern_extraction">
      <description>Extract messaging and event-driven patterns</description>
      <heuristics>
        <rule>Identify message broker technology (RabbitMQ, Kafka, etc.)</rule>
        <rule>Document event publishing patterns</rule>
        <rule>Extract event handling and subscription patterns</rule>
        <rule>Note message serialization formats</rule>
        <rule>Identify error handling and dead letter queues</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Messaging technology and patterns</item>
        <item>Event publishing conventions</item>
        <item>Event handling patterns</item>
        <item>Error handling strategies</item>
      </evidence_to_collect>
    </technique>
  </integration_analysis_techniques>

  <security_analysis_techniques>
    <technique name="authentication_pattern_extraction">
      <description>Extract authentication and authorization patterns</description>
      <heuristics>
        <rule>Identify authentication mechanisms (JWT, sessions, OAuth, etc.)</rule>
        <rule>Document authorization patterns (RBAC, ABAC, etc.)</rule>
        <rule>Extract token management and refresh patterns</rule>
        <rule>Note password hashing and storage approaches</rule>
        <rule>Identify session management patterns</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Authentication mechanisms</item>
        <item>Authorization patterns</item>
        <item>Token/session management</item>
        <item>Security best practices followed</item>
      </evidence_to_collect>
    </technique>

    <technique name="security_pattern_identification">
      <description>Identify security patterns and practices</description>
      <heuristics>
        <rule>Document input validation and sanitization</rule>
        <rule>Identify CSRF protection mechanisms</rule>
        <rule>Extract XSS prevention patterns</rule>
        <rule>Note SQL injection prevention approaches</rule>
        <rule>Identify sensitive data handling patterns</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Security patterns implemented</item>
        <item>Vulnerability prevention approaches</item>
        <item>Sensitive data handling</item>
      </evidence_to_collect>
    </technique>
  </security_analysis_techniques>

  <performance_analysis_techniques>
    <technique name="optimization_pattern_extraction">
      <description>Extract performance optimization patterns</description>
      <heuristics>
        <rule>Identify caching strategies and implementations</rule>
        <rule>Document database query optimization patterns</rule>
        <rule>Extract async/concurrent processing patterns</rule>
        <rule>Note lazy loading and pagination approaches</rule>
        <rule>Identify resource pooling patterns</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Caching strategies</item>
        <item>Query optimization patterns</item>
        <item>Concurrency patterns</item>
        <item>Resource management</item>
      </evidence_to_collect>
    </technique>
  </performance_analysis_techniques>

  <documentation_analysis_techniques>
    <technique name="existing_documentation_review">
      <description>Review and incorporate existing documentation</description>
      <heuristics>
        <rule>Read README files at all levels</rule>
        <rule>Review API documentation if present</rule>
        <rule>Check for architecture diagrams or docs</rule>
        <rule>Look for developer guides and setup docs</rule>
        <rule>Review inline code comments for insights</rule>
      </heuristics>
      <evidence_to_collect>
        <item>Key insights from existing docs</item>
        <item>Documented patterns and conventions</item>
        <item>Setup and workflow information</item>
      </evidence_to_collect>
    </technique>
  </documentation_analysis_techniques>

  <quality_indicators>
    <indicator name="pattern_consistency">
      <checks>
        <check>Same pattern used consistently across codebase</check>
        <check>Conventions followed uniformly</check>
        <check>No conflicting approaches for same problem</check>
      </checks>
    </indicator>

    <indicator name="documentation_quality">
      <checks>
        <check>Code comments explain "why" not just "what"</check>
        <check>Complex logic has explanatory comments</check>
        <check>Public APIs have documentation</check>
        <check>README files present and informative</check>
      </checks>
    </indicator>

    <indicator name="architectural_integrity">
      <checks>
        <check>Layer boundaries respected</check>
        <check>Dependencies flow in correct direction</check>
        <check>No circular dependencies</check>
        <check>Appropriate abstractions present</check>
      </checks>
    </indicator>
  </quality_indicators>

  <extraction_workflow>
    <phase name="discovery">
      <description>Initial codebase exploration and structure understanding</description>
      <steps>
        <step>Analyze directory structure and organization</step>
        <step>Review package manifests and dependencies</step>
        <step>Read top-level documentation (README, docs/)</step>
        <step>Identify technology stack and frameworks</step>
      </steps>
    </phase>

    <phase name="pattern_extraction">
      <description>Systematic extraction of patterns and conventions</description>
      <steps>
        <step>Apply architecture analysis techniques</step>
        <step>Extract naming and organization conventions</step>
        <step>Identify recurring code patterns</step>
        <step>Document integration patterns</step>
        <step>Extract testing and configuration patterns</step>
      </steps>
    </phase>

    <phase name="anti_pattern_identification">
      <description>Identify things to avoid</description>
      <steps>
        <step>Look for code smells and anti-patterns</step>
        <step>Identify architectural violations</step>
        <step>Document why they're problematic</step>
        <step>Provide correct alternatives</step>
      </steps>
    </phase>

    <phase name="synthesis">
      <description>Organize and structure extracted knowledge</description>
      <steps>
        <step>Organize patterns by category</step>
        <step>Create examples from actual code</step>
        <step>Document rationale and trade-offs</step>
        <step>Generate bootstrap artifacts</step>
      </steps>
    </phase>
  </extraction_workflow>
</extraction_techniques>